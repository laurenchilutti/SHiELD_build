#!/bin/bash
#***********************************************************************
#*                   GNU Lesser General Public License
#*
#* This file is part of the SHiELD Build System.
#*
#* The SHiELD Build System free software: you can redistribute it
#* and/or modify it under the terms of the
#* GNU Lesser General Public License as published by the
#* Free Software Foundation, either version 3 of the License, or
#* (at your option) any later version.
#*
#* The SHiELD Build System distributed in the hope that it will be
#* useful, but WITHOUT ANY WARRANTY; without even the implied warranty
#* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#* See the GNU General Public License for more details.
#*
#* You should have received a copy of the GNU Lesser General Public
#* License along with theSHiELD Build System
#* If not, see <http://www.gnu.org/licenses/>.
#***********************************************************************
#
#  DISCLAIMER: This script is provided as-is and as such is unsupported.
#

#
# function to display a spinning wheel while a command is in progress
spin()
{
  spinner="\\|/-\\|/-"
  while :
  do
    for i in `seq 0 7`
    do
      echo -n "${spinner:$i:1}"
      echo -en "\010"
      sleep 1
    done
  done
}
# end function

#
#------------------------------------------------------------------------------
# functional code below this point

#
# set default values
#
# configure your build parameters
  config="shield"
  hydro="nh"
  comp="prod"
  bit="32bit"
  avx="Y"
  compiler="intel"
  clean="noclean"
  serial="noserial"
  yaml="noyaml"
  pic="nopic"

  config_name="SHiELD"

#
# parse arguments
  for arg in "$@"
  do
      case $arg in
          shield|solo)
             config="${arg#*=}"
             if [ $config = 'solo' ] ; then
               config_name="SOLO"
             fi
             shift # Remove "config" from processing
             ;;
          nh|hydro|sw)
             hydro="${arg#*=}"
             shift # remove "hydro" from processing
             ;;
          prod|repro|debug)
             comp="${arg#*=}"
             shift # remove "comp" from processing
             ;;
          32bit|64bit)
             bit="${arg#*=}"
             shift # remove "bit" from processing
             ;;
          avx|noavx)
             if [ ${arg#*} = 'noavx' ] ; then
               avx="N"
             fi
             shift # remove "avx from processing
             ;;
          intel|gnu|nvhpc)
             compiler="${arg#*=}"
             shift # Remove "compiler" from processing
             if [ ${compiler} = 'nvhpc' ] ; then
               echo -e ' '
               echo -e "The NVidia compiler has only been tested with the CI scripts."
               echo -e "A runtime bug with v23.1 occurs when deallocating the Atm Fortran derived data type."
               echo -e "The bug can be worked around by commenting out the offfending line of code."
               echo -e "\n"
               sleep 20
             fi
             ;;
          noclean|clean|cleanall)
             clean="${arg#*=}"
             shift # Remove "clean" from processing
             ;;
          noserial|serial)
             serial="${arg#*=}"
             shift # Remove "serial" from processing
             ;;
          noyaml|yaml)
             yaml="${arg#*=}"
             shift # Remove "yaml" from processing
             ;;
          nopic|pic)
             pic="${arg#*=}"
             shift # Remove "pic" from processing
             ;;
          *)
          if [ ${arg#} != '--help' ] && [ ${arg#} != '-h' ] ; then
            echo "option "${arg#}" not found"
          fi
          echo -e ' '
          echo -e "valid options are:"
          echo -e "\t[shield(D) | solo] \t\t\t configuration"
          echo -e "\t[nh(D) | hydro | sw] \t\t\t executable configuration"
          echo -e "\t[prod(D) | repro | debug] \t\t compiler option settings"
          echo -e "\t[32bit(D) | 64bit] \t\t\t FV3 precision option"
          echo -e "\t[avx(D) | noavx] \t\t\t use AVX_LEVEL defined in site/environment.<compiler>.sh"
          echo -e "\t[intel(D) | gnu | nvhpc] \t\t\t compiler"
          echo -e "\t[noclean(D) | clean | cleanall] \t cleans exec area"
          echo -e "\t[noserial(D) | serial] \t\t\t seialbox support"
	  echo -e "\t[noyaml(D) | yaml] \t will build the FMS library with the -Duse_yaml library.  Default is no yaml"
          echo -e "\t[nopic(D) | pic] \t whether to build all components with the -fPIC flag (position independent code)"
          echo -e "\n"
          exit
          ;;
      esac
  done

if [ $hydro = "sw" ] && [ $config = "shield" ] ; then
  echo -e ">>> option '$hydro' with '$config' is not a valid configuration"
  exit 1
fi

#
# set up some default variables for use within the helper scripts
export BUILD_ROOT=${PWD%/*}
export SHiELD_SRC=${PWD%/*/*}/SHiELD_SRC
export PATH="${BUILD_ROOT}/mkmf/bin:${BUILD_ROOT}/Build/mk_scripts:${PATH}"
export NCEP_DIR=${BUILD_ROOT}/Build
export SERIALBOX_ROOT=/autofs/ncrc-svm1_home2/Oliver.Elbert/code/repos/serialbox/install
export PP_SER=${SERIALBOX_ROOT}/python/pp_ser/pp_ser.py
export PPSER_FLAGS="--verbose --ignore-identical -m utils_ppser_kbuff"
export SERIALBOX_OUTDIR=${PWD%/*/*}/SERIALBOX_BUILD

#
# load the proper environment for your machine
. ${BUILD_ROOT}/site/environment.${compiler}.sh

#
# output the build setup
echo -e ' '
echo -e "Compilation will continue in five seconds with"
echo -e "\tconfig   = $config"
echo -e "\thydro    = $hydro"
echo -e "\tcomp     = $comp"
echo -e "\tbit      = $bit"
echo -e "\tavx      = $avx"
echo -e "\tcompiler = $compiler"
echo -e "\tclean    = $clean"
echo -e "\tserial   = $serial"
echo -e "\tyaml     = $yaml"
echo -e "\tpic      = $pic"
echo -e "\n"
sleep 5

#
# start the spinner
spin &
SPIN_PID=$!
trap "kill -9 $SPIN_PID" `seq 0 15`

#
# test for mkmf
if [ ! -f "${BUILD_ROOT}/mkmf/bin/mkmf" ] ; then
   echo -e ' '
   echo -e "The mkmf submodule has not been initialized"
   echo -e "Please run this command in the SHiELD_build base directory:"
   echo -e "\tgit submodule update --init mkmf"
   echo -e "\n"
   exit 0
fi


#
# conditionally clean the build directory
  if [ ${clean} = "cleanall" ] ; then
     echo " cleaning FMS library, nceplibs and build directory in 2 seconds"
     sleep 2
     \rm -rf libFMS/${compiler}/*
     \rm -rf exec/${config}_${hydro}.${comp}.${bit}.${compiler}/*
     \rm -rf nceplibs/${compiler}/*
  elif [ ${clean} = "clean" ] ; then
     echo " cleaning build directory in 2 seconds"
     sleep 2
     \rm -rf exec/${config}_${hydro}.${comp}.${bit}.${compiler}/*
  fi

# If EXTERNAL_LIBS is set, then the program will use the path defined by
#    EXTERNAL_LIBS as the location of nceplibs and libFMS
  if [ ! -z ${EXTERNAL_LIBS} ] ; then
    echo " External Libraries are being used: ${EXTERNAL_LIBS}"
    export NCEP_DIR=${EXTERNAL_LIBS}
  fi
#
# check to make sure libFMS exists
  if [ -d ${NCEP_DIR}/libFMS/${compiler} ] && [ -e ${NCEP_DIR}/libFMS/${compiler}/32bit/libFMS.a ] && \
     [ -e ${NCEP_DIR}/libFMS/${compiler}/64bit/libFMS.a ] ; then
     echo " pre-built ${NCEP_DIR}/libFMS/${compiler} exists"
  else
     echo " ${NCEP_DIR}/libFMS/${compiler} does not exist"
     ./BUILDlibfms ${compiler} ${yaml} ${pic}
     if [ $? -ne 0 ] ; then
        echo ">>> ${NCEP_DIR}/Libfms/${compiler} build failed"
        exit 2
     fi
  fi
# check to make sure nceplibs exists
  if [ -d ${NCEP_DIR}/nceplibs/${compiler} ] && [ -e ${NCEP_DIR}/nceplibs/${compiler}/libbacio.a ] && \
     [ -e ${NCEP_DIR}/nceplibs/${compiler}/libsp_d.a ] && [ -e ${NCEP_DIR}/nceplibs/${compiler}/libw3emc_d.a ] && \
     [ -e ${NCEP_DIR}/nceplibs/${compiler}/libw3nco_d.a ] ; then
     echo " pre-built ${NCEP_DIR}/nceplibs/${compiler} exists"
  else
     echo " ${NCEP_DIR}/nceplibs/${compiler} does not exist"
     ./BUILDnceplibs ${compiler} ${pic}
     if [ $? -ne 0 ] ; then
        echo ">>> ${NCEP_DIR}/ncepdir/${compiler} build failed"
        exit 3
     fi
  fi

#
# ensure the build and final executable locations are available
  mkdir -p ./exec/${config}_${hydro}.${comp}.${bit}.${compiler}
  mkdir -p ./bin/

# build the model
echo -e "  building ${config} ${hydro} ${comp} ${bit} ${compiler} ${serial} \t `date`"
  #
  # optionally run serialbox preprocessor
  if [ $serial = "serial" ] ; then
    echo -e ">>> preprocessing code for serialization"
    # make directories for serialbox-preprocessed code
    # Currently only doing physics, but we can add more as necessary
    mkdir -p $SERIALBOX_OUTDIR/SHiELD_physics/GFS_layer/
    mkdir -p $SERIALBOX_OUTDIR/SHiELD_physics/simple_coupler/
    mkdir -p $SERIALBOX_OUTDIR/SHiELD_physics/gsmphys/
    mkdir -p $SERIALBOX_OUTDIR/SHiELD_physics/IPD_layer/
    mkdir -p $SERIALBOX_OUTDIR/SHiELD_physics/FV3GFS/
    mkdir -p $SERIALBOX_OUTDIR/FMSCoupler/SHiELD/
    mkdir -p $SERIALBOX_OUTDIR/GFDL_atmos_cubed_sphere/driver/SHiELD/
    mkdir -p $SERIALBOX_OUTDIR/GFDL_atmos_cubed_sphere/model/
    
    # run preprocessor
    python3 $PP_SER $PPSER_FLAGS --output-dir=$SERIALBOX_OUTDIR/SHiELD_physics/GFS_layer/ $SHiELD_SRC/SHiELD_physics/GFS_layer/*.F90
    python3 $PP_SER $PPSER_FLAGS --output-dir=$SERIALBOX_OUTDIR/SHiELD_physics/gsmphys/ $SHiELD_SRC/SHiELD_physics/gsmphys/*.F90
    python3 $PP_SER $PPSER_FLAGS --output-dir=$SERIALBOX_OUTDIR/SHiELD_physics/simple_coupler/ $SHiELD_SRC/SHiELD_physics/simple_coupler/*.F90
    python3 $PP_SER $PPSER_FLAGS --output-dir=$SERIALBOX_OUTDIR/SHiELD_physics/IPD_layer/ $SHiELD_SRC/SHiELD_physics/IPD_layer/*.F90
    python3 $PP_SER $PPSER_FLAGS --output-dir=$SERIALBOX_OUTDIR/SHiELD_physics/FV3GFS/ $SHiELD_SRC/SHiELD_physics/FV3GFS/*.F90
    python3 $PP_SER $PPSER_FLAGS --output-dir=$SERIALBOX_OUTDIR/FMSCoupler/SHiELD/ $SHiELD_SRC/FMSCoupler/SHiELD/*.F90
    python3 $PP_SER $PPSER_FLAGS --output-dir=$SERIALBOX_OUTDIR/GFDL_atmos_cubed_sphere/driver/SHiELD/ $SHiELD_SRC/GFDL_atmos_cubed_sphere/driver/SHiELD/*.F90
    python3 $PP_SER $PPSER_FLAGS --output-dir=$SERIALBOX_OUTDIR/GFDL_atmos_cubed_sphere/model/ $SHiELD_SRC/GFDL_atmos_cubed_sphere/model/*.F90
    
    # copy back to src location to preserve rest of build system
    cp $SERIALBOX_OUTDIR/SHiELD_physics/GFS_layer/* $SHiELD_SRC/SHiELD_physics/GFS_layer/
    cp $SERIALBOX_OUTDIR/SHiELD_physics/gsmphys/* $SHiELD_SRC/SHiELD_physics/gsmphys/
    cp $SERIALBOX_OUTDIR/SHiELD_physics/simple_coupler/* $SHiELD_SRC/SHiELD_physics/simple_coupler/
    cp $SERIALBOX_OUTDIR/SHiELD_physics/IPD_layer/* $SHiELD_SRC/SHiELD_physics/IPD_layer/
    cp $SERIALBOX_OUTDIR/SHiELD_physics/FV3GFS/* $SHiELD_SRC/SHiELD_physics/FV3GFS/
    cp $SERIALBOX_OUTDIR/FMSCoupler/SHiELD/* $SHiELD_SRC/FMSCoupler/SHiELD/
    cp $SERIALBOX_OUTDIR/GFDL_atmos_cubed_sphere/driver/SHiELD/* $SHiELD_SRC/GFDL_atmos_cubed_sphere/driver/SHiELD/
    cp $SERIALBOX_OUTDIR/GFDL_atmos_cubed_sphere/model/* $SHiELD_SRC/GFDL_atmos_cubed_sphere/model/
    echo -e "Finished preprocessing for serialization"

  fi
  #
  # create the file list for the build
    mk_paths ${config} ${hydro} ${comp} ${bit} ${compiler}       > build_${config}_${hydro}.${comp}.${bit}.${compiler}.out 2>&1
    if [ $? -ne 0 ] ; then
       echo ">>> filelist cration failed"
       exit 4
    fi
  #
  # create the library makefiles
    mk_makefile ${config} ${hydro} ${comp} ${bit} ${compiler} ${serial}    >> build_${config}_${hydro}.${comp}.${bit}.${compiler}.out 2>&1
    if [ $? -ne 0 ] ; then
       echo ">>> makefile creation failed"
       exit 5
    fi
  #
  # build the configuration
    mk_make ${config} ${hydro} ${comp} ${bit} ${avx} ${compiler} ${pic} >> build_${config}_${hydro}.${comp}.${bit}.${compiler}.out 2>&1
  #
  # move the executable to an accessible area
    mv exec/${config}_${hydro}.${comp}.${bit}.${compiler}/test.x bin/${config_name}_${hydro}.${comp}.${bit}.${compiler}.x

#
# test and report on build success
  if [ $? -ne 0 ] ; then
     echo ">>> ${config_name} build ${hydro} ${comp} ${bit} ${compiler} ${serial} failed"
     exit 6
  else
     echo " ${config_name} build ${hydro} ${comp} ${bit} ${compiler} ${serial} successful"
  fi

exit 0
